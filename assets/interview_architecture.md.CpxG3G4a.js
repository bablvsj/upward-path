import{_ as e,c as a,o as l,a5 as p}from"./chunks/framework.Drr5GMcH.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/architecture.md","filePath":"interview/architecture.md","lastUpdated":1721296625000}'),i={name:"interview/architecture.md"},c=p(`<h2 id="webpack" tabindex="-1">Webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to &quot;Webpack&quot;">​</a></h2><h3 id="_1-webpack-简介" tabindex="-1">1. webpack 简介 <a class="header-anchor" href="#_1-webpack-简介" aria-label="Permalink to &quot;1. webpack 简介&quot;">​</a></h3><p><code>webpack</code>的作用其实有以下几点：</p><ul><li><p>模块打包。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。</p></li><li><p>编译兼容。在前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过<code>webpack</code>的<code>Loader</code>机制，不仅仅可以帮助我们对代码做<code>polyfill</code>，还可以编译转换诸如<code>.less, .vue, .jsx</code>这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。</p></li><li><p>能力扩展。通过<code>webpack</code>的<code>Plugin</code>机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。</p></li></ul><h3 id="_2-有哪些常见的loader-你用过哪些loader" tabindex="-1">2. 有哪些常见的Loader？你用过哪些Loader？ <a class="header-anchor" href="#_2-有哪些常见的loader-你用过哪些loader" aria-label="Permalink to &quot;2. 有哪些常见的Loader？你用过哪些Loader？&quot;">​</a></h3><p>webpack 本体只能处理原生的 JavaScript 模块，你让它处理 <code>css</code> 或图片资源，它是无法直接处理的。为了处理这种问题，webpack 提供了 <strong>loader</strong> 的机制，用于对模块外的源码进行转换。</p><ul><li><p><code>file-loader</code>：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</p></li><li><p><code>url-loader</code>：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</p></li><li><p><code>source-map-loader</code>：加载额外的 Source Map 文件，以方便断点调试</p></li><li><p><code>svg-inline-loader</code>：将压缩后的 SVG 内容注入代码中</p></li><li><p><code>image-loader</code>：加载并且压缩图片文件</p></li><li><p><code>json-loader</code> 加载 JSON 文件（默认包含）</p></li><li><p><code>babel-loader</code>：把 ES6 转换成 ES5</p></li><li><p><code>ts-loader</code>: 将 TypeScript 转换成 JavaScript</p></li><li><p><code>sass-loader</code>：将SCSS/SASS代码转换成CSS</p></li><li><p><code>css-loader</code>：加载 CSS，支持模块化、压缩、文件导入等特性</p></li><li><p><code>style-loader</code>：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</p></li><li><p><code>postcss-loader</code>：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</p></li><li><p><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码</p></li><li><p><code>tslint-loader</code>：通过 TSLint检查 TypeScript 代码</p></li><li><p><code>vue-loader</code>：加载 Vue.js 单文件组件</p></li><li><p><code>i18n-loader</code>: 国际化</p></li><li><p><code>cache-loader</code>: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</p></li></ul><h3 id="_3-有哪些plugin" tabindex="-1">3. 有哪些Plugin <a class="header-anchor" href="#_3-有哪些plugin" aria-label="Permalink to &quot;3. 有哪些Plugin&quot;">​</a></h3><ul><li><p><code>define-plugin</code>：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</p></li><li><p><code>ignore-plugin</code>：忽略部分文件</p></li><li><p><code>html-webpack-plugin</code>：简化 HTML 文件创建 (依赖于 html-loader)</p></li><li><p><code>web-webpack-plugin</code>：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用</p></li><li><p><code>uglifyjs-webpack-plugin</code>：不支持 ES6 压缩 (Webpack4 以前)</p></li><li><p><code>terser-webpack-plugin</code>: 支持压缩 ES6 (Webpack4)</p></li><li><p><code>webpack-parallel-uglify-plugin</code>: 多进程执行代码压缩，提升构建速度</p></li><li><p><code>mini-css-extract-plugin</code>: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)</p></li><li><p><code>serviceworker-webpack-plugin</code>：为网页应用增加离线缓存功能</p></li><li><p><code>clean-webpack-plugin</code>: 目录清理</p></li><li><p><code>ModuleConcatenationPlugin</code>: 开启 Scope Hoisting</p></li><li><p><code>speed-measure-webpack-plugin</code>: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)</p></li><li><p><code>webpack-bundle-analyzer</code>: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</p></li></ul><h3 id="_4-loader-与-plugin的区别" tabindex="-1">4. Loader 与 Plugin的区别 <a class="header-anchor" href="#_4-loader-与-plugin的区别" aria-label="Permalink to &quot;4. Loader 与 Plugin的区别&quot;">​</a></h3><p><code>Loader</code>负责文件转换，那么<code>Plugin</code>便是负责功能扩展。 <code>Loader</code>和<code>Plugin</code>作为<code>Webpack</code>的两个重要组成部分，承担着两部分不同的职责</p><h3 id="_115-谈谈你对-webpack-的看法" tabindex="-1">115. 谈谈你对 webpack 的看法 <a class="header-anchor" href="#_115-谈谈你对-webpack-的看法" aria-label="Permalink to &quot;115. 谈谈你对 webpack 的看法&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源</span></span>
<span class="line"><span>数。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。</span></span></code></pre></div><p>详细资料可以参考： <a href="https://juejin.im/post/5b38d27451882574d87aa5d5#heading-0" target="_blank" rel="noreferrer">《不聊 webpack 配置，来说说它的原理》</a><a href="https://juejin.im/entry/5b5724d05188251aa01647fd" target="_blank" rel="noreferrer">《前端工程化——构建工具选型：grunt、gulp、webpack》</a><a href="https://juejin.im/post/5afa9cd0f265da0b981b9af9#heading-0" target="_blank" rel="noreferrer">《浅入浅出 webpack》</a><a href="https://juejin.im/entry/5ae5c8c9f265da0b9f400d8e" target="_blank" rel="noreferrer">《前端构建工具发展及其比较》</a></p><h3 id="谈谈webpack、vite和gulp三者之间的区别" tabindex="-1">谈谈Webpack、Vite和Gulp三者之间的区别 <a class="header-anchor" href="#谈谈webpack、vite和gulp三者之间的区别" aria-label="Permalink to &quot;谈谈Webpack、Vite和Gulp三者之间的区别&quot;">​</a></h3><p>Webpack、Vite 和 Gulp 是三种流行的前端构建工具，它们之间有一些显著的区别：</p><ol><li>Webpack： <ul><li>Webpack 是一个模块打包器，主要用于 JavaScript 应用程序的打包和优化。</li><li>它支持各种资源（如 JS、CSS、图片、字体等）的加载和处理。</li><li>Webpack 支持代码分割、懒加载、Tree Shaking 等优化策略，有助于提高应用程序的性能。</li><li>通过插件系统，Webpack 可以进行高度定制，满足各种项目需求。</li><li>缺点是配置相对复杂，构建速度在某些情况下较慢。</li></ul></li><li>Vite： <ul><li>Vite 是一个基于 ES modules 的开发服务器和构建工具，由 Vue.js 作者尤雨溪创建。</li><li>Vite 利用原生 ES 模块（ESM）特性，实现快速开发服务器和按需编译。</li><li>Vite 支持 HMR（热模块替换），提高开发效率。</li><li>Vite 使用 Rollup 进行生产环境构建，具有出色的 Tree Shaking 能力。</li><li>Vite 配置相对简单，易于上手，但某些场景下可能没有 Webpack 那么灵活。</li></ul></li><li>Gulp： <ul><li>Gulp 是一个基于流（stream）的任务运行器，主要用于自动化处理前端资源。</li><li>Gulp 通过编写任务，可以实现各种复杂的构建流程，如编译 SASS、压缩 JS 等。</li><li>Gulp 的核心优势在于其流式处理，减少磁盘 I/O，提高任务执行速度。</li><li>Gulp 使用代码定义任务，具有很好的灵活性，适用于简单项目或高度定制化的构建需求。</li><li>缺点是 Gulp 不支持模块打包，需要与其他工具（如 Webpack、Rollup）结合使用以实现完整的构建流程。</li></ul></li></ol><p>总结：</p><p>Webpack、Vite 和 Gulp 之间的主要区别在于它们的使用场景、核心功能和处理方式。</p><p>Webpack 是一个功能丰富的模块打包器，适用于各种类型的项目。</p><p>Vite 是一个轻量级、高性能的开发服务器和构建工具，尤其适用于现代框架项目。</p><p>Gulp 是一个灵活的任务运行器，用于处理前端资源和自动化工作流。</p><p>在实际项目中，开发者可以根据需求选择合适的工具，甚至将它们组合使用以实现最佳的构建流程。</p>`,23),o=[c];function n(d,s,r,t,u,b){return l(),a("div",null,o)}const S=e(i,[["render",n]]);export{h as __pageData,S as default};
