import{_ as e,c as o,o as l,a4 as a}from"./chunks/framework.b8L46xkR.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/architecture.md","filePath":"interview/architecture.md","lastUpdated":1720173465000}'),c={name:"interview/architecture.md"},d=a('<h2 id="webpack" tabindex="-1">Webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to &quot;Webpack&quot;">​</a></h2><h3 id="_1-webpack-简介" tabindex="-1">1. webpack 简介 <a class="header-anchor" href="#_1-webpack-简介" aria-label="Permalink to &quot;1. webpack 简介&quot;">​</a></h3><p><code>webpack</code>的作用其实有以下几点：</p><ul><li><p>模块打包。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。</p></li><li><p>编译兼容。在前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过<code>webpack</code>的<code>Loader</code>机制，不仅仅可以帮助我们对代码做<code>polyfill</code>，还可以编译转换诸如<code>.less, .vue, .jsx</code>这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。</p></li><li><p>能力扩展。通过<code>webpack</code>的<code>Plugin</code>机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。</p></li></ul><h3 id="_2-有哪些常见的loader-你用过哪些loader" tabindex="-1">2. 有哪些常见的Loader？你用过哪些Loader？ <a class="header-anchor" href="#_2-有哪些常见的loader-你用过哪些loader" aria-label="Permalink to &quot;2. 有哪些常见的Loader？你用过哪些Loader？&quot;">​</a></h3><p>webpack 本体只能处理原生的 JavaScript 模块，你让它处理 <code>css</code> 或图片资源，它是无法直接处理的。为了处理这种问题，webpack 提供了 <strong>loader</strong> 的机制，用于对模块外的源码进行转换。</p><ul><li><p><code>file-loader</code>：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</p></li><li><p><code>url-loader</code>：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</p></li><li><p><code>source-map-loader</code>：加载额外的 Source Map 文件，以方便断点调试</p></li><li><p><code>svg-inline-loader</code>：将压缩后的 SVG 内容注入代码中</p></li><li><p><code>image-loader</code>：加载并且压缩图片文件</p></li><li><p><code>json-loader</code> 加载 JSON 文件（默认包含）</p></li><li><p><code>babel-loader</code>：把 ES6 转换成 ES5</p></li><li><p><code>ts-loader</code>: 将 TypeScript 转换成 JavaScript</p></li><li><p><code>sass-loader</code>：将SCSS/SASS代码转换成CSS</p></li><li><p><code>css-loader</code>：加载 CSS，支持模块化、压缩、文件导入等特性</p></li><li><p><code>style-loader</code>：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</p></li><li><p><code>postcss-loader</code>：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</p></li><li><p><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码</p></li><li><p><code>tslint-loader</code>：通过 TSLint检查 TypeScript 代码</p></li><li><p><code>vue-loader</code>：加载 Vue.js 单文件组件</p></li><li><p><code>i18n-loader</code>: 国际化</p></li><li><p><code>cache-loader</code>: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</p></li></ul><h3 id="_3-有哪些plugin" tabindex="-1">3. 有哪些Plugin <a class="header-anchor" href="#_3-有哪些plugin" aria-label="Permalink to &quot;3. 有哪些Plugin&quot;">​</a></h3><ul><li><p><code>define-plugin</code>：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</p></li><li><p><code>ignore-plugin</code>：忽略部分文件</p></li><li><p><code>html-webpack-plugin</code>：简化 HTML 文件创建 (依赖于 html-loader)</p></li><li><p><code>web-webpack-plugin</code>：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用</p></li><li><p><code>uglifyjs-webpack-plugin</code>：不支持 ES6 压缩 (Webpack4 以前)</p></li><li><p><code>terser-webpack-plugin</code>: 支持压缩 ES6 (Webpack4)</p></li><li><p><code>webpack-parallel-uglify-plugin</code>: 多进程执行代码压缩，提升构建速度</p></li><li><p><code>mini-css-extract-plugin</code>: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)</p></li><li><p><code>serviceworker-webpack-plugin</code>：为网页应用增加离线缓存功能</p></li><li><p><code>clean-webpack-plugin</code>: 目录清理</p></li><li><p><code>ModuleConcatenationPlugin</code>: 开启 Scope Hoisting</p></li><li><p><code>speed-measure-webpack-plugin</code>: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)</p></li><li><p><code>webpack-bundle-analyzer</code>: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</p></li></ul><h3 id="_4-loader-与-plugin的区别" tabindex="-1">4. Loader 与 Plugin的区别 <a class="header-anchor" href="#_4-loader-与-plugin的区别" aria-label="Permalink to &quot;4. Loader 与 Plugin的区别&quot;">​</a></h3><p><code>Loader</code>负责文件转换，那么<code>Plugin</code>便是负责功能扩展。 <code>Loader</code>和<code>Plugin</code>作为<code>Webpack</code>的两个重要组成部分，承担着两部分不同的职责</p><h2 id="amd-cmd-esmodule" tabindex="-1">AMD / CMD / ESModule <a class="header-anchor" href="#amd-cmd-esmodule" aria-label="Permalink to &quot;AMD / CMD / ESModule&quot;">​</a></h2><p>CommonJs</p><p>webpack 配置是标准的 Node.js的CommonJS 模块，它通过require来引入其他模块，通过module.exports导出模块</p>',14),i=[d];function p(r,t,n,u,s,b){return l(),o("div",null,i)}const k=e(c,[["render",p]]);export{h as __pageData,k as default};
