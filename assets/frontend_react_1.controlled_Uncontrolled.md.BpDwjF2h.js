import{_ as i,c as a,o as t,ai as n}from"./chunks/framework.CidjA1rH.js";const o=JSON.parse('{"title":"说说对受控组件和非受控组件的理解？应用场景？","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/react/1.controlled_Uncontrolled.md","filePath":"frontend/react/1.controlled_Uncontrolled.md","lastUpdated":1756656444000}'),l={name:"frontend/react/1.controlled_Uncontrolled.md"};function e(h,s,p,k,d,r){return t(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="说说对受控组件和非受控组件的理解-应用场景" tabindex="-1">说说对受控组件和非受控组件的理解？应用场景？ <a class="header-anchor" href="#说说对受控组件和非受控组件的理解-应用场景" aria-label="Permalink to &quot;说说对受控组件和非受控组件的理解？应用场景？&quot;">​</a></h1><h3 id="一、什么是受控组件" tabindex="-1">一、什么是受控组件？ <a class="header-anchor" href="#一、什么是受控组件" aria-label="Permalink to &quot;一、什么是受控组件？&quot;">​</a></h3><h4 id="_1-1-定义" tabindex="-1">1.1 定义 <a class="header-anchor" href="#_1-1-定义" aria-label="Permalink to &quot;1.1 定义&quot;">​</a></h4><p>受控组件是指组件的状态由React的<code>state</code>或<code>props</code>来管理的组件。换句话说，组件的值完全由React控制，而不是由DOM本身维护。在受控组件中，用户输入的值通过<code>onChange</code>事件或其他事件处理器传递给React的<code>state</code>，然后React再将新的值重新渲染到DOM中。</p><h4 id="_1-2-实现方式" tabindex="-1">1.2 实现方式 <a class="header-anchor" href="#_1-2-实现方式" aria-label="Permalink to &quot;1.2 实现方式&quot;">​</a></h4><p>在React中，受控组件通常通过<code>value</code>属性和<code>onChange</code>事件来实现。<code>value</code>属性用于设置输入框的当前值，而<code>onChange</code>事件则用于监听用户的输入并更新<code>state</code>。以下是一个简单的受控组件示例：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React, { useState } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ControlledInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">inputValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setInputValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleChange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setInputValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.target.value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      输入框：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{inputValue}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        onChange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{handleChange}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;当前输入的值：{inputValue}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ControlledInput;</span></span></code></pre></div><h4 id="_1-3-优点" tabindex="-1">1.3 优点 <a class="header-anchor" href="#_1-3-优点" aria-label="Permalink to &quot;1.3 优点&quot;">​</a></h4><ol><li><p><strong>状态集中管理</strong>：受控组件的状态由React统一管理，便于调试和维护。开发者可以通过<code>state</code>轻松跟踪组件的状态变化，避免了状态分散在DOM中的问题。</p></li><li><p><strong>易于验证和处理</strong>：由于所有输入都通过<code>onChange</code>事件传递给React，开发者可以在事件处理函数中对用户输入进行实时验证、格式化或转换。例如，可以在用户输入时立即检查输入是否符合某种规则，并给出相应的提示。</p></li><li><p><strong>更好的可测试性</strong>：受控组件的状态完全由React控制，因此在单元测试中可以轻松模拟<code>state</code>的变化，验证组件的行为是否符合预期。</p></li><li><p><strong>支持复杂的交互逻辑</strong>：受控组件可以与其他React组件（如表单、按钮等）进行联动，实现复杂的交互逻辑。例如，可以根据用户的输入动态更新其他组件的状态，或者根据多个输入字段的组合结果执行特定的操作。</p></li></ol><h4 id="_1-4-缺点" tabindex="-1">1.4 缺点 <a class="header-anchor" href="#_1-4-缺点" aria-label="Permalink to &quot;1.4 缺点&quot;">​</a></h4><ol><li><p><strong>性能开销</strong>：每次用户输入都会触发<code>onChange</code>事件，进而导致<code>state</code>更新和组件重新渲染。对于频繁的输入操作（如实时搜索、自动补全等），这可能会带来一定的性能开销，尤其是在大型应用中。</p></li><li><p><strong>代码复杂度增加</strong>：受控组件需要为每个输入字段编写<code>onChange</code>事件处理函数，并且需要维护相应的<code>state</code>。对于包含大量输入字段的复杂表单，这会导致代码量显著增加，增加了开发和维护的成本。</p></li></ol><hr><h3 id="二、什么是非受控组件" tabindex="-1">二、什么是非受控组件？ <a class="header-anchor" href="#二、什么是非受控组件" aria-label="Permalink to &quot;二、什么是非受控组件？&quot;">​</a></h3><h4 id="_2-1-定义" tabindex="-1">2.1 定义 <a class="header-anchor" href="#_2-1-定义" aria-label="Permalink to &quot;2.1 定义&quot;">​</a></h4><p>非受控组件是指组件的状态不由React的<code>state</code>或<code>props</code>管理，而是由DOM本身维护的组件。换句话说，非受控组件的值由DOM直接管理，React只是通过<code>ref</code>来访问这些值。非受控组件类似于传统的HTML表单，用户输入的值直接存储在DOM中，React不会主动干预其变化。</p><h4 id="_2-2-实现方式" tabindex="-1">2.2 实现方式 <a class="header-anchor" href="#_2-2-实现方式" aria-label="Permalink to &quot;2.2 实现方式&quot;">​</a></h4><p>在React中，非受控组件通常通过<code>ref</code>来实现。<code>ref</code>是一个特殊的属性，它可以用来引用DOM元素或类组件实例。通过<code>ref</code>，开发者可以直接访问DOM元素的属性和方法，获取或设置其值。以下是一个简单的非受控组件示例：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React, { useRef } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UncontrolledInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> inputRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleSubmit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">preventDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;当前输入的值：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, inputRef.current.value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">form</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onSubmit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{handleSubmit}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        输入框：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{inputRef} /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;submit&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;提交&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">form</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UncontrolledInput;</span></span></code></pre></div><h4 id="_2-3-优点" tabindex="-1">2.3 优点 <a class="header-anchor" href="#_2-3-优点" aria-label="Permalink to &quot;2.3 优点&quot;">​</a></h4><ol><li><p><strong>性能优势</strong>：非受控组件不需要为每个输入字段编写<code>onChange</code>事件处理函数，也不会频繁触发<code>state</code>更新和组件重新渲染。因此，对于频繁的输入操作，非受控组件具有更好的性能表现。</p></li><li><p><strong>代码简洁</strong>：非受控组件的代码相对简单，尤其是对于简单的表单或输入字段较少的应用场景。开发者只需要通过<code>ref</code>访问DOM元素的值即可，无需维护复杂的<code>state</code>。</p></li><li><p><strong>适合与第三方库集成</strong>：某些第三方库（如富文本编辑器、日期选择器等）可能依赖于DOM的原生行为，使用非受控组件可以更容易地与这些库集成，避免因React的<code>state</code>管理而导致的冲突。</p></li></ol><h4 id="_2-4-缺点" tabindex="-1">2.4 缺点 <a class="header-anchor" href="#_2-4-缺点" aria-label="Permalink to &quot;2.4 缺点&quot;">​</a></h4><ol><li><p><strong>状态分散</strong>：非受控组件的状态由DOM维护，导致状态分散在多个地方，难以集中管理和调试。开发者无法通过React的<code>state</code>来跟踪组件的状态变化，增加了调试的难度。</p></li><li><p><strong>难以进行实时验证</strong>：由于非受控组件的值由DOM直接管理，React无法在用户输入时立即获取到最新的值，因此难以实现实时验证或格式化。开发者只能在表单提交时获取最终的值，错过了实时反馈的机会。</p></li><li><p><strong>可测试性较差</strong>：非受控组件的状态不由React控制，因此在单元测试中难以模拟DOM的变化，验证组件的行为变得更加困难。</p></li><li><p><strong>不支持复杂的交互逻辑</strong>：非受控组件无法与其他React组件进行联动，难以实现复杂的交互逻辑。例如，无法根据用户的输入动态更新其他组件的状态，或者根据多个输入字段的组合结果执行特定的操作。</p></li></ol><hr><h3 id="三、受控组件与非受控组件的对比" tabindex="-1">三、受控组件与非受控组件的对比 <a class="header-anchor" href="#三、受控组件与非受控组件的对比" aria-label="Permalink to &quot;三、受控组件与非受控组件的对比&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>受控组件</th><th>非受控组件</th></tr></thead><tbody><tr><td><strong>状态管理</strong></td><td>由React的<code>state</code>或<code>props</code>管理</td><td>由DOM本身维护</td></tr><tr><td><strong>值的来源</strong></td><td><code>value</code>属性</td><td><code>ref</code>引用</td></tr><tr><td><strong>事件处理</strong></td><td><code>onChange</code>事件</td><td>无特定事件处理</td></tr><tr><td><strong>性能</strong></td><td>每次输入都会触发<code>state</code>更新和重新渲染，可能带来性能开销</td><td>不需要频繁更新<code>state</code>，性能较好</td></tr><tr><td><strong>代码复杂度</strong></td><td>需要为每个输入字段编写<code>onChange</code>事件处理函数，代码较复杂</td><td>代码简洁，尤其是对于简单的表单</td></tr><tr><td><strong>可测试性</strong></td><td>状态由React控制，易于测试</td><td>状态由DOM维护，测试难度较大</td></tr><tr><td><strong>适用场景</strong></td><td>复杂表单、需要实时验证、动态交互</td><td>简单表单、性能敏感、与第三方库集成</td></tr></tbody></table><hr><p><strong>记住：日常开发，优先用受控组件！遇到文件上传或特殊集成，再用非受控。</strong></p>`,27)])])}const g=i(l,[["render",e]]);export{o as __pageData,g as default};
