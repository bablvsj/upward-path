import{_ as e,c as a,o as r,ai as l}from"./chunks/framework.BSQvje64.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/harmony/code_advanced.md","filePath":"frontend/harmony/code_advanced.md","lastUpdated":1761875361000}'),i={name:"frontend/harmony/code_advanced.md"};function o(n,t,s,d,h,p){return r(),a("div",null,[...t[0]||(t[0]=[l('<h3 id="一次开发-多端部署" tabindex="-1">一次开发，多端部署 <a class="header-anchor" href="#一次开发-多端部署" aria-label="Permalink to &quot;一次开发，多端部署&quot;">​</a></h3><h4 id="页面级一多" tabindex="-1">页面级一多 <a class="header-anchor" href="#页面级一多" aria-label="Permalink to &quot;页面级一多&quot;">​</a></h4><h5 id="布局能力" tabindex="-1">布局能力 <a class="header-anchor" href="#布局能力" aria-label="Permalink to &quot;布局能力&quot;">​</a></h5><p><strong>自适应布局(Adaptive Layout)</strong></p><p>针对常见的开发场景，方舟开发框架提炼了七种自适应布局能力，这些布局可以独立使用，也可多种布局叠加使用。</p><p><strong>表2</strong></p><table tabindex="0"><thead><tr><th style="text-align:left;">自适应布局能力</th><th style="text-align:left;">使用场景</th><th style="text-align:left;">实现方式</th></tr></thead><tbody><tr><td style="text-align:left;">拉伸能力</td><td style="text-align:left;">容器组件尺寸发生变化时，增加或减小的空间<br>全部分配给容器组件内指定区域。</td><td style="text-align:left;">Flex布局的flexGrow和flexShrink属性</td></tr><tr><td style="text-align:left;">均分能力</td><td style="text-align:left;">容器组件尺寸发生变化时，增加或减小的空间<br>均匀分配给容器组件内所有空白区域。</td><td style="text-align:left;">Row组件、Column组件或Flex<br>组件的justifyContent属性设置为FlexAlign.SpaceEvenly</td></tr><tr><td style="text-align:left;">占比能力</td><td style="text-align:left;">子组件的宽或高按照预设的比例，随容器组件<br>发生变化。</td><td style="text-align:left;">基于通用属性的两种实现方式：<br><br>- 将子组件的宽高设置为<br>父组件宽高的百分比<br><br>- layoutWeight属性</td></tr><tr><td style="text-align:left;">缩放能力</td><td style="text-align:left;">子组件的宽高按照预设的比例，随容器组件<br>发生变化，且变化过程中子组件的宽高比不变。</td><td style="text-align:left;">布局约束的aspectRatio属性</td></tr><tr><td style="text-align:left;">延伸能力</td><td style="text-align:left;">容器组件内的子组件，按照其在列表中的<br>先后顺序，随容器组件尺寸变化显示或隐藏。</td><td style="text-align:left;">基于容器组件的两种实现方式：<br><br>- 通过List组件实现<br><br>- 通过Scroll组件配合Row组件或<br>Column组件实现</td></tr><tr><td style="text-align:left;">隐藏能力</td><td style="text-align:left;">容器组件内的子组件，按照其预设的显示优先级，随容器组件尺寸变化显示或隐藏。<br>相同显示优先级的子组件同时显示或隐藏。</td><td style="text-align:left;">布局约束的displayPriority属性</td></tr><tr><td style="text-align:left;">折行能力</td><td style="text-align:left;">容器组件尺寸发生变化时，如果布局方向尺寸不足以显示完整内容，自动换行。</td><td style="text-align:left;">Flex组件的wrap属性设置为FlexWrap.Wrap</td></tr></tbody></table><p><strong>响应式布局(Responsive Layout)</strong></p><p>响应式布局是指页面内的元素可以根据特定的特征（如窗口宽度、屏幕方向等）自动变化以适应外部容器变化的布局能力。响应式布局中最常使用的特征是窗口宽度，可以将窗口宽度划分为不同的范围（下文中称为断点）。当窗口宽度从一个断点变化到另一个断点时，改变页面布局（如将页面内容从单列排布调整为双列排布甚至三列排布等）以获得更好的显示效果。</p><p><strong>表3</strong></p><table tabindex="0"><thead><tr><th style="text-align:left;">响应式布局能力</th><th style="text-align:left;">简介</th></tr></thead><tbody><tr><td style="text-align:left;">断点</td><td style="text-align:left;">将窗口宽度划分为不同的范围（即断点），监听窗口尺寸变化，当断点改变时同步调整页面布局。</td></tr><tr><td style="text-align:left;">媒体查询</td><td style="text-align:left;">媒体查询<strong>支持监听窗口宽度、横竖屏、深浅色、设备类型等多种媒体特征</strong>，当媒体特征发生改变时同步调整页面布局。</td></tr><tr><td style="text-align:left;">栅格布局</td><td style="text-align:left;">栅格组件将其所在的区域划分为有规律的多列，通过调整不同断点下的栅格组件的参数以及其子组件占据的列数等，实现不同的布局效果。</td></tr></tbody></table><h5 id="资源使用" tabindex="-1">资源使用 <a class="header-anchor" href="#资源使用" aria-label="Permalink to &quot;资源使用&quot;">​</a></h5><p>在页面开发过程中，经常需要用到颜色、字体、间距、图片等资源，在不同的设备或配置中，这些资源的值可能不同。有两种方式处理：</p><ul><li>应用资源：借助资源文件能力，开发者在应用中自定义资源，自行管理这些资源在不同的设备或配置中的表现。通过&quot;$r(&#39;app.media.icon&#39;)&quot;的形式引用系统资源（<strong>app代表是应用资源</strong>）。</li><li>系统资源：开发者直接使用系统预置的资源定义，通过&quot;$r(&#39;sys.type.resource_id&#39;)&quot;的形式引用系统资源（<strong>sys代表是系统资源</strong>）。</li></ul><h5 id="交互归一" tabindex="-1">交互归一 <a class="header-anchor" href="#交互归一" aria-label="Permalink to &quot;交互归一&quot;">​</a></h5><p>对于不同类型的智能设备，用户可能有不同的交互方式，如通过触摸屏、鼠标、触控板等。如果针对不同的交互方式单独做适配，会增加开发工作量同时产生大量重复代码。为解决这一问题，我们统一了各种交互方式的API，即实现了交互归一。</p><p>常见的基础输入方式及其在各输入设备上的表现如下图所示。</p><h4 id="功能级一多" tabindex="-1">功能级一多 <a class="header-anchor" href="#功能级一多" aria-label="Permalink to &quot;功能级一多&quot;">​</a></h4><p>应用开发至少包含两部分工作： UI页面开发和底层功能开发（部分需要联网的应用还会涉及服务端开发）。前面章节介绍了如何解决页面适配的问题，本章节主要介绍应用如何解决设备系统能力差异的兼容问题。</p><h5 id="系统能力" tabindex="-1">系统能力 <a class="header-anchor" href="#系统能力" aria-label="Permalink to &quot;系统能力&quot;">​</a></h5><p>系统能力（<strong>即SystemCapability，缩写为SysCap</strong>）指操作系统中每一个相对独立的特性，如蓝牙，WIFI，NFC，摄像头等，都是系统能力之一。每个系统能力对应多个API，随着目标设备是否支持该系统能力共同存在或消失。</p><p>与系统能力相关的，有支持能力集、联想能力集和要求能力集三个核心概念。</p><ul><li>支持能力集：设备具备的系统能力集合，在设备配置文件中配置。</li><li>要求能力集：应用需要的系统能力集合，在应用配置文件中配置。</li><li>联想能力集：开发应用时IDE可联想的API所在的系统能力集合，在应用配置文件中配置。</li></ul><h5 id="动态逻辑判断" tabindex="-1">动态逻辑判断 <a class="header-anchor" href="#动态逻辑判断" aria-label="Permalink to &quot;动态逻辑判断&quot;">​</a></h5><p>如果某个系统能力没有写入应用的要求能力集中，那么在使用前需要判断设备是否支持该系统能力。</p><h5 id="配置联想能力集和要求能力集" tabindex="-1">配置联想能力集和要求能力集 <a class="header-anchor" href="#配置联想能力集和要求能力集" aria-label="Permalink to &quot;配置联想能力集和要求能力集&quot;">​</a></h5><ul><li>IDE会根据创建的工程所支持的设备自动配置联想能力集和要求能力集，同时也支持开发者修改。</li></ul><h4 id="工程级一多" tabindex="-1">工程级一多 <a class="header-anchor" href="#工程级一多" aria-label="Permalink to &quot;工程级一多&quot;">​</a></h4><p>工程级一多需要考虑如何实现一套代码同时能部署到多种不同设备上，代码工程如何组织。</p><h5 id="应用程序包结构" tabindex="-1">应用程序包结构 <a class="header-anchor" href="#应用程序包结构" aria-label="Permalink to &quot;应用程序包结构&quot;">​</a></h5><p>在进行应用开发时，一个应用通常包含一个或多个Module。Module是HarmonyOS应用/服务的基本功能单元，包含了源代码、资源文件、第三方库及应用/服务配置文件，每一个Module都可以独立进行编译和运行。</p><p>Module分为“Ability”和“Library”两种类型：</p><ul><li>“Ability”类型的Module编译后生成HAP包。</li><li>“Library”类型的Module编译后生成HAR包。</li></ul><p>HarmonyOS的应用以APP Pack形式发布，其包含一个或多个HAP包。HAP是HarmonyOS应用安装的基本单位，HAP可以分为Entry和Feature两种类型：</p><ul><li>Entry类型的HAP：应用的主模块。在同一个应用中，同一设备类型只支持一个Entry类型的HAP，通常用于实现应用的入口界面、入口图标、主特性功能等。</li><li>Feature类型的HAP：应用的动态特性模块。Feature类型的HAP通常用于实现应用的特性功能，一个应用程序包可以包含一个或多个Feature类型的HAP，也可以不包含。</li></ul><h5 id="部署模型" tabindex="-1">部署模型 <a class="header-anchor" href="#部署模型" aria-label="Permalink to &quot;部署模型&quot;">​</a></h5><p>“一多”有两种部署模型：</p><ul><li>部署模型A：不同类型的设备上按照一定的工程结构组织方式，通过一次编译生成相同的HAP（或HAP组合）。</li><li>部署模型B：不同类型的设备上按照一定的工程结构组织方式，通过一次编译生成不同的HAP（或HAP组合）。</li></ul><p>开发者可以从应用UX设计及应用功能两个维度，结合具体的业务场景，考虑选择哪种部署模型。当然，也可以借助设备类型分类，快速做出判断。</p><p>从屏幕尺寸、输入方式及交互距离三个维度考虑，可以将常用类型的设备分为不同泛类：</p><ul><li>默认设备、平板</li><li>车机、智慧屏</li><li>智能穿戴</li><li>……</li></ul><h5 id="工程结构" tabindex="-1">工程结构 <a class="header-anchor" href="#工程结构" aria-label="Permalink to &quot;工程结构&quot;">​</a></h5><p>“一多”推荐在应用开发过程中使用如下的“三层工程结构”。</p><ul><li><p>common（公共能力层）：用于存放<strong>公共基础能力集合</strong>（如工具库、公共配置等）。 common层不可分割，需编译成一个HAR包，其只可以被products和features依赖，不可以反向依赖。</p></li><li><p>features（基础特性层）：用于存放<strong>基础特性集合</strong>（如应用中相对独立的各个功能的UI及业务逻辑实现等）。 各个feature高内聚、低耦合、可定制，供产品灵活部署。不需要单独部署的feature通常编译为HAR包，供products或其它feature使用。需要单独部署的feature通常编译为Feature类型的HAP包，和products下Entry类型的HAP包进行组合部署。features层可以横向调用及依赖common层，同时可以被products层不同设备形态的HAP所依赖，但是不能反向依赖products层。</p></li><li><p>products（产品定制层）：用于<strong>针对不同设备形态进行功能和特性集成</strong>。 products层各个子目录各自编译为一个Entry类型的HAP包，作为应用主入口。products层不可以横向调用。</p></li></ul><h3 id="自由流转" tabindex="-1">自由流转 <a class="header-anchor" href="#自由流转" aria-label="Permalink to &quot;自由流转&quot;">​</a></h3><h4 id="场景介绍" tabindex="-1">场景介绍 <a class="header-anchor" href="#场景介绍" aria-label="Permalink to &quot;场景介绍&quot;">​</a></h4><p>随着全场景多设备的生活方式不断深入，用户拥有的设备越来越多，不同设备都能在适合的场景下提供良好的体验，例如手表可以提供及时的信息查看能力，电视可以带来沉浸的观影体验。但是，每个设备也有使用场景的局限，例如在电视上输入文本相对移动设备来说是非常糟糕的体验。当多个设备通过分布式操作系统能够相互感知、进而整合成一个超级终端时，设备与设备之间就可以取长补短、相互帮助，为用户提供更加自然流畅的分布式体验。</p><p>在HarmonyOS中，将跨多设备的分布式操作统称为<strong>流转</strong>；根据使用场景的不同，流转又分为跨端迁移和多端协同两种具体场景。</p><h4 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h4><ul><li><p><strong>流转</strong></p><p>在HarmonyOS中泛指跨多设备的分布式操作。流转能力打破设备界限，多设备联动，使用户应用程序可分可合、可流转，实现如邮件跨设备编辑、多设备协同健身、多屏游戏等分布式业务。流转为开发者提供更广的使用场景和更新的产品视角，强化产品优势，实现体验升级。流转按照使用场景可分为<strong>跨端迁移</strong>和<strong>多端协同</strong>。</p></li><li><p><strong>跨端迁移</strong></p><p>在用户使用设备的过程中，当使用情境发生变化时（例如从室内走到户外或者周围有更合适的设备等），之前使用的设备可能已经不适合继续当前的任务，此时，用户可以选择新的设备来继续当前的任务，原设备可按需决定是否退出任务，这就是跨端迁移场景。</p><p>常见的跨端迁移场景实例：在平板上播放的视频，迁移到智慧屏继续播放，从而获得更佳的观看体验；平板上的视频应用退出。</p><p>在应用开发层面，跨端迁移指在A端运行的UIAbility迁移到B端上，完成迁移后，B端UIAbility继续任务，而A端UIAbility可按需决定是否退出。</p></li><li><p><strong>多端协同</strong></p><p>用户拥有的多个设备，可以作为一个整体，为用户提供比单设备更加高效、沉浸的体验，这就是多端协同场景。</p><p>常见的多端协同场景实例：</p><p>场景一：两台设备A和B打开备忘录同一篇笔记进行双端协同编辑，在设备A上可以使用本地图库中的图片资源插入编辑，设备B上进行文字内容编辑。</p><p>场景二：设备A上正在和客户进行聊天，客户需要的资料在设备B上，可以通过聊天软件打开设备B上的文档应用选择到想要的资料回传到设备A上，然后通过聊天软件发送给客户。</p><p>在应用开发层面，多端协同指多端上的不同UIAbility/ServiceExtensionAbility同时运行、或者交替运行实现完整的业务；或者多端上的相同UIAbility/ServiceExtensionAbility同时运行实现完整的业务。</p></li></ul><h4 id="典型场景" tabindex="-1">典型场景 <a class="header-anchor" href="#典型场景" aria-label="Permalink to &quot;典型场景&quot;">​</a></h4><ul><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/distributed-playback-overview-V5" target="_blank" rel="noreferrer">媒体播控</a>：使用媒体播控，可以简单高效地将音频投放到其他HarmonyOS设备上播放，如在手机上播放的音频，可以投到2in1设备上继续播放。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/app-continuation-overview-V5" target="_blank" rel="noreferrer">应用接续</a>：指当用户在一个设备上操作某个应用时，可以在另一个设备的同一个应用中快速切换，并无缝衔接上一个设备的应用体验。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/distributed-drag-overview-V5" target="_blank" rel="noreferrer">跨设备拖拽</a>：跨端拖拽提供跨设备的键鼠共享能力，支持在平板或2in1类型的任意两台设备之间拖拽文件、文本。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/distributed-pasteboard-overview-V5" target="_blank" rel="noreferrer">跨设备剪贴板</a>：当用户拥有多台设备时，可以通过跨设备剪贴板的功能，在A设备的应用上复制一段文本，粘贴到B设备的应用中，高效地完成多设备间的内容共享。</li></ul><h4 id="申请权限并启用接续能力" tabindex="-1">申请权限并启用接续能力 <a class="header-anchor" href="#申请权限并启用接续能力" aria-label="Permalink to &quot;申请权限并启用接续能力&quot;">​</a></h4><ol><li><p>申请权限。</p><blockquote><ul><li>如果仅使用want迁移数据，无需申请权限。</li><li>如果需要使用分布式文件或分布式对象迁移数据，需要申请权限。</li></ul></blockquote><ol><li>数据迁移需要申请ohos.permission.DISTRIBUTED_DATASYNC权限，详见<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/declare-permissions-V5" target="_blank" rel="noreferrer">声明权限</a>。</li><li>由于数据迁移使用权限需要用户授权，所以在应用首次启动时弹窗向用户申请授权，详见<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/request-user-authorization-V5" target="_blank" rel="noreferrer">向用户申请授权</a>。</li></ol></li><li><p>启用应用接续能力。 在module.json5文件的abilities中，将continuable标签配置为“true”，表示该UIAbility可被迁移。配置为false的UIAbility将被系统识别为无法迁移且该配置默认值为false。</p></li></ol><p>数据传输方式</p><ul><li>文件类型的数据：采用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/distributed-fs-overview-V5" target="_blank" rel="noreferrer">分布式文件系统</a>进行传输。</li><li>其他类型的数据： <ul><li>少量数据（100KB以下）：在onContinue回调中使用wantParam传输。</li><li>保存除文件以外的数据，主要包括发件人（sender）、收件人（recipient）、主题（subject）、内容（emailContent）、附件元信息（appendix）等。这些数据量较少，可采用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-appstorage-V5" target="_blank" rel="noreferrer">AppStorage</a>对页面数据进行保存</li><li>大量数据（100KB及以上）：采用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/sync-app-data-across-devices-overview-V5" target="_blank" rel="noreferrer">分布式数据对象</a>进行传输。</li></ul></li></ul><p><strong>传输业务数据</strong>：使用UIAbility中onContinue()接口实现数据传递，将数据传输到对端设备。 <strong>恢复数据</strong>：如果采用wantParam传输数据，需要使用onCreate()和onNewWant()接口加载数据。如果采用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/sync-app-data-across-devices-overview-V5" target="_blank" rel="noreferrer">分布式数据对象</a>传输数据，则需要使用分布式数据对象恢复数据。</p><h3 id="应用性能优化" tabindex="-1">应用性能优化 <a class="header-anchor" href="#应用性能优化" aria-label="Permalink to &quot;应用性能优化&quot;">​</a></h3><p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ide-profiler-0000001818152621-V5" target="_blank" rel="noreferrer">Profiler 性能分析工具</a></p><h4 id="应用冷启动过程" tabindex="-1">应用冷启动过程 <a class="header-anchor" href="#应用冷启动过程" aria-label="Permalink to &quot;应用冷启动过程&quot;">​</a></h4><p>应用启动时，后台无该应用的进程，需要创建新的进程，这种启动方式叫做冷启动，<strong>冷启动</strong>的过程大致可分成下面四个阶段：<strong>应用进程创建和初始化、App和Ability的初始化、Ability生命周期、加载绘制首页</strong>。</p><blockquote><ol><li>缩短应用进程创建&amp;初始化阶段耗时:设置合适分辨率的startwindowIcon</li><li>缩短Application&amp;Ability初始化阶段耗时:减少首页Ability或者Page中import的模块</li><li>缩短Ability生命周期阶段耗时:使用异步加载</li><li>缩短加载绘制首页阶段耗时:延迟加载</li></ol></blockquote><h3 id="应用开发安全" tabindex="-1">应用开发安全 <a class="header-anchor" href="#应用开发安全" aria-label="Permalink to &quot;应用开发安全&quot;">​</a></h3><h3 id="应用dfx能力" tabindex="-1">应用DFX能力 <a class="header-anchor" href="#应用dfx能力" aria-label="Permalink to &quot;应用DFX能力&quot;">​</a></h3>',64)])])}const b=e(i,[["render",o]]);export{c as __pageData,b as default};
