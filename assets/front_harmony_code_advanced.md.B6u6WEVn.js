import{_ as t,c as e,o as a,a5 as l}from"./chunks/framework.S2LsLKlc.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"front/harmony/code_advanced.md","filePath":"front/harmony/code_advanced.md","lastUpdated":1723025131000}'),r={name:"front/harmony/code_advanced.md"},i=l('<h3 id="一次开发-多端部署" tabindex="-1">一次开发，多端部署 <a class="header-anchor" href="#一次开发-多端部署" aria-label="Permalink to &quot;一次开发，多端部署&quot;">​</a></h3><h4 id="页面级一多" tabindex="-1">页面级一多 <a class="header-anchor" href="#页面级一多" aria-label="Permalink to &quot;页面级一多&quot;">​</a></h4><h5 id="布局能力" tabindex="-1">布局能力 <a class="header-anchor" href="#布局能力" aria-label="Permalink to &quot;布局能力&quot;">​</a></h5><p><strong>自适应布局(Adaptive Layout)</strong></p><p>针对常见的开发场景，方舟开发框架提炼了七种自适应布局能力，这些布局可以独立使用，也可多种布局叠加使用。</p><p><strong>表2</strong></p><table tabindex="0"><thead><tr><th style="text-align:left;">自适应布局能力</th><th style="text-align:left;">使用场景</th><th style="text-align:left;">实现方式</th></tr></thead><tbody><tr><td style="text-align:left;">拉伸能力</td><td style="text-align:left;">容器组件尺寸发生变化时，增加或减小的空间<br>全部分配给容器组件内指定区域。</td><td style="text-align:left;">Flex布局的flexGrow和flexShrink属性</td></tr><tr><td style="text-align:left;">均分能力</td><td style="text-align:left;">容器组件尺寸发生变化时，增加或减小的空间<br>均匀分配给容器组件内所有空白区域。</td><td style="text-align:left;">Row组件、Column组件或Flex<br>组件的justifyContent属性设置为FlexAlign.SpaceEvenly</td></tr><tr><td style="text-align:left;">占比能力</td><td style="text-align:left;">子组件的宽或高按照预设的比例，随容器组件<br>发生变化。</td><td style="text-align:left;">基于通用属性的两种实现方式：<br><br>- 将子组件的宽高设置为<br>父组件宽高的百分比<br><br>- layoutWeight属性</td></tr><tr><td style="text-align:left;">缩放能力</td><td style="text-align:left;">子组件的宽高按照预设的比例，随容器组件<br>发生变化，且变化过程中子组件的宽高比不变。</td><td style="text-align:left;">布局约束的aspectRatio属性</td></tr><tr><td style="text-align:left;">延伸能力</td><td style="text-align:left;">容器组件内的子组件，按照其在列表中的<br>先后顺序，随容器组件尺寸变化显示或隐藏。</td><td style="text-align:left;">基于容器组件的两种实现方式：<br><br>- 通过List组件实现<br><br>- 通过Scroll组件配合Row组件或<br>Column组件实现</td></tr><tr><td style="text-align:left;">隐藏能力</td><td style="text-align:left;">容器组件内的子组件，按照其预设的显示优先级，随容器组件尺寸变化显示或隐藏。<br>相同显示优先级的子组件同时显示或隐藏。</td><td style="text-align:left;">布局约束的displayPriority属性</td></tr><tr><td style="text-align:left;">折行能力</td><td style="text-align:left;">容器组件尺寸发生变化时，如果布局方向尺寸不足以显示完整内容，自动换行。</td><td style="text-align:left;">Flex组件的wrap属性设置为FlexWrap.Wrap</td></tr></tbody></table><p><strong>响应式布局(Responsive Layout)</strong></p><p>响应式布局是指页面内的元素可以根据特定的特征（如窗口宽度、屏幕方向等）自动变化以适应外部容器变化的布局能力。响应式布局中最常使用的特征是窗口宽度，可以将窗口宽度划分为不同的范围（下文中称为断点）。当窗口宽度从一个断点变化到另一个断点时，改变页面布局（如将页面内容从单列排布调整为双列排布甚至三列排布等）以获得更好的显示效果。</p><p><strong>表3</strong></p><table tabindex="0"><thead><tr><th style="text-align:left;">响应式布局能力</th><th style="text-align:left;">简介</th></tr></thead><tbody><tr><td style="text-align:left;">断点</td><td style="text-align:left;">将窗口宽度划分为不同的范围（即断点），监听窗口尺寸变化，当断点改变时同步调整页面布局。</td></tr><tr><td style="text-align:left;">媒体查询</td><td style="text-align:left;">媒体查询支持监听窗口宽度、横竖屏、深浅色、设备类型等多种媒体特征，当媒体特征发生改变时同步调整页面布局。</td></tr><tr><td style="text-align:left;">栅格布局</td><td style="text-align:left;">栅格组件将其所在的区域划分为有规律的多列，通过调整不同断点下的栅格组件的参数以及其子组件占据的列数等，实现不同的布局效果。</td></tr></tbody></table><h5 id="资源使用" tabindex="-1">资源使用 <a class="header-anchor" href="#资源使用" aria-label="Permalink to &quot;资源使用&quot;">​</a></h5><p>在页面开发过程中，经常需要用到颜色、字体、间距、图片等资源，在不同的设备或配置中，这些资源的值可能不同。有两种方式处理：</p><ul><li>应用资源：借助资源文件能力，开发者在应用中自定义资源，自行管理这些资源在不同的设备或配置中的表现。通过&quot;$r(&#39;app.media.icon&#39;)&quot;的形式引用系统资源（<strong>app代表是应用资源</strong>）。</li><li>系统资源：开发者直接使用系统预置的资源定义，通过&quot;$r(&#39;sys.type.resource_id&#39;)&quot;的形式引用系统资源（<strong>sys代表是系统资源</strong>）。</li></ul><h5 id="交互归一" tabindex="-1">交互归一 <a class="header-anchor" href="#交互归一" aria-label="Permalink to &quot;交互归一&quot;">​</a></h5><p>对于不同类型的智能设备，用户可能有不同的交互方式，如通过触摸屏、鼠标、触控板等。如果针对不同的交互方式单独做适配，会增加开发工作量同时产生大量重复代码。为解决这一问题，我们统一了各种交互方式的API，即实现了交互归一。</p><p>常见的基础输入方式及其在各输入设备上的表现如下图所示。</p><h4 id="功能级一多" tabindex="-1">功能级一多 <a class="header-anchor" href="#功能级一多" aria-label="Permalink to &quot;功能级一多&quot;">​</a></h4><p>应用开发至少包含两部分工作： UI页面开发和底层功能开发（部分需要联网的应用还会涉及服务端开发）。前面章节介绍了如何解决页面适配的问题，本章节主要介绍应用如何解决设备系统能力差异的兼容问题。</p><h5 id="系统能力" tabindex="-1">系统能力 <a class="header-anchor" href="#系统能力" aria-label="Permalink to &quot;系统能力&quot;">​</a></h5><p>系统能力（即SystemCapability，缩写为SysCap）指操作系统中每一个相对独立的特性，如蓝牙，WIFI，NFC，摄像头等，都是系统能力之一。每个系统能力对应多个API，随着目标设备是否支持该系统能力共同存在或消失。</p><p>与系统能力相关的，有支持能力集、联想能力集和要求能力集三个核心概念。</p><ul><li>支持能力集：设备具备的系统能力集合，在设备配置文件中配置。</li><li>要求能力集：应用需要的系统能力集合，在应用配置文件中配置。</li><li>联想能力集：开发应用时IDE可联想的API所在的系统能力集合，在应用配置文件中配置。</li></ul><h5 id="动态逻辑判断" tabindex="-1">动态逻辑判断 <a class="header-anchor" href="#动态逻辑判断" aria-label="Permalink to &quot;动态逻辑判断&quot;">​</a></h5><p>如果某个系统能力没有写入应用的要求能力集中，那么在使用前需要判断设备是否支持该系统能力。</p><h5 id="配置联想能力集和要求能力集" tabindex="-1">配置联想能力集和要求能力集 <a class="header-anchor" href="#配置联想能力集和要求能力集" aria-label="Permalink to &quot;配置联想能力集和要求能力集&quot;">​</a></h5><ul><li>IDE会根据创建的工程所支持的设备自动配置联想能力集和要求能力集，同时也支持开发者修改。</li></ul><h4 id="工程级一多" tabindex="-1">工程级一多 <a class="header-anchor" href="#工程级一多" aria-label="Permalink to &quot;工程级一多&quot;">​</a></h4><p>工程级一多需要考虑如何实现一套代码同时能部署到多种不同设备上，代码工程如何组织。</p><h5 id="应用程序包结构" tabindex="-1">应用程序包结构 <a class="header-anchor" href="#应用程序包结构" aria-label="Permalink to &quot;应用程序包结构&quot;">​</a></h5><p>在进行应用开发时，一个应用通常包含一个或多个Module。Module是HarmonyOS应用/服务的基本功能单元，包含了源代码、资源文件、第三方库及应用/服务配置文件，每一个Module都可以独立进行编译和运行。</p><p>Module分为“Ability”和“Library”两种类型：</p><ul><li>“Ability”类型的Module编译后生成HAP包。</li><li>“Library”类型的Module编译后生成HAR包。</li></ul><p>HarmonyOS的应用以APP Pack形式发布，其包含一个或多个HAP包。HAP是HarmonyOS应用安装的基本单位，HAP可以分为Entry和Feature两种类型：</p><ul><li>Entry类型的HAP：应用的主模块。在同一个应用中，同一设备类型只支持一个Entry类型的HAP，通常用于实现应用的入口界面、入口图标、主特性功能等。</li><li>Feature类型的HAP：应用的动态特性模块。Feature类型的HAP通常用于实现应用的特性功能，一个应用程序包可以包含一个或多个Feature类型的HAP，也可以不包含。</li></ul><h5 id="部署模型" tabindex="-1">部署模型 <a class="header-anchor" href="#部署模型" aria-label="Permalink to &quot;部署模型&quot;">​</a></h5><p>“一多”有两种部署模型：</p><ul><li>部署模型A：不同类型的设备上按照一定的工程结构组织方式，通过一次编译生成相同的HAP（或HAP组合）。</li><li>部署模型B：不同类型的设备上按照一定的工程结构组织方式，通过一次编译生成不同的HAP（或HAP组合）。</li></ul><p>开发者可以从应用UX设计及应用功能两个维度，结合具体的业务场景，考虑选择哪种部署模型。当然，也可以借助设备类型分类，快速做出判断。</p><p>从屏幕尺寸、输入方式及交互距离三个维度考虑，可以将常用类型的设备分为不同泛类：</p><ul><li>默认设备、平板</li><li>车机、智慧屏</li><li>智能穿戴</li><li>……</li></ul><h5 id="工程结构" tabindex="-1">工程结构 <a class="header-anchor" href="#工程结构" aria-label="Permalink to &quot;工程结构&quot;">​</a></h5><p>“一多”推荐在应用开发过程中使用如下的“三层工程结构”。</p><ul><li><p>common（公共能力层）：用于存放<strong>公共基础能力集合</strong>（如工具库、公共配置等）。 common层不可分割，需编译成一个HAR包，其只可以被products和features依赖，不可以反向依赖。</p></li><li><p>features（基础特性层）：用于存放<strong>基础特性集合</strong>（如应用中相对独立的各个功能的UI及业务逻辑实现等）。 各个feature高内聚、低耦合、可定制，供产品灵活部署。不需要单独部署的feature通常编译为HAR包，供products或其它feature使用。需要单独部署的feature通常编译为Feature类型的HAP包，和products下Entry类型的HAP包进行组合部署。features层可以横向调用及依赖common层，同时可以被products层不同设备形态的HAP所依赖，但是不能反向依赖products层。</p></li><li><p>products（产品定制层）：用于<strong>针对不同设备形态进行功能和特性集成</strong>。 products层各个子目录各自编译为一个Entry类型的HAP包，作为应用主入口。products层不可以横向调用。</p></li></ul><h3 id="应用性能优化" tabindex="-1">应用性能优化 <a class="header-anchor" href="#应用性能优化" aria-label="Permalink to &quot;应用性能优化&quot;">​</a></h3><h3 id="应用开发安全" tabindex="-1">应用开发安全 <a class="header-anchor" href="#应用开发安全" aria-label="Permalink to &quot;应用开发安全&quot;">​</a></h3><h3 id="应用dfx能力" tabindex="-1">应用DFX能力 <a class="header-anchor" href="#应用dfx能力" aria-label="Permalink to &quot;应用DFX能力&quot;">​</a></h3>',47),o=[i];function d(n,s,h,u,p,c){return a(),e("div",null,o)}const y=t(r,[["render",d]]);export{b as __pageData,y as default};
