import{_ as a,c as r,o,ai as n}from"./chunks/framework.BSQvje64.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/interview/project.md","filePath":"frontend/interview/project.md","lastUpdated":1761875361000}'),t={name:"frontend/interview/project.md"};function p(l,e,i,h,c,d){return o(),r("div",null,[...e[0]||(e[0]=[n(`<h2 id="提供更多专业技能的具体案例或成果-例如-在-熟练使用vue2-vue3-部分-可以详细说明具体使用这些技术解决了什么问题或实现了什么功能。" tabindex="-1">提供更多专业技能的具体案例或成果，例如：在&quot;熟练使用Vue2，Vue3&quot;部分，可以详细说明具体使用这些技术解决了什么问题或实现了什么功能。 <a class="header-anchor" href="#提供更多专业技能的具体案例或成果-例如-在-熟练使用vue2-vue3-部分-可以详细说明具体使用这些技术解决了什么问题或实现了什么功能。" aria-label="Permalink to &quot;提供更多专业技能的具体案例或成果，例如：在&quot;熟练使用Vue2，Vue3&quot;部分，可以详细说明具体使用这些技术解决了什么问题或实现了什么功能。&quot;">​</a></h2><h2 id="教育经历部分可以加入更多描述-比如所获奖项、参与的项目或相关课程-以更好体现专业背景。" tabindex="-1">教育经历部分可以加入更多描述，比如所获奖项、参与的项目或相关课程，以更好体现专业背景。 <a class="header-anchor" href="#教育经历部分可以加入更多描述-比如所获奖项、参与的项目或相关课程-以更好体现专业背景。" aria-label="Permalink to &quot;教育经历部分可以加入更多描述，比如所获奖项、参与的项目或相关课程，以更好体现专业背景。&quot;">​</a></h2><h2 id="对于工作经历和项目经历可以添加一些量化的成果-例如提高了多少性能-减少了多少加载时间-或者通过优化减少了多少项目开销等-以更具体地突出您的成绩。" tabindex="-1">对于工作经历和项目经历可以添加一些量化的成果，例如提高了多少性能，减少了多少加载时间，或者通过优化减少了多少项目开销等，以更具体地突出您的成绩。 <a class="header-anchor" href="#对于工作经历和项目经历可以添加一些量化的成果-例如提高了多少性能-减少了多少加载时间-或者通过优化减少了多少项目开销等-以更具体地突出您的成绩。" aria-label="Permalink to &quot;对于工作经历和项目经历可以添加一些量化的成果，例如提高了多少性能，减少了多少加载时间，或者通过优化减少了多少项目开销等，以更具体地突出您的成绩。&quot;">​</a></h2><h2 id="如果有更多个人博客、github项目或者曾经参与的开源项目-建议添加链接-以证明技术实力和项目经历。" tabindex="-1">如果有更多个人博客、GitHub项目或者曾经参与的开源项目，建议添加链接，以证明技术实力和项目经历。 <a class="header-anchor" href="#如果有更多个人博客、github项目或者曾经参与的开源项目-建议添加链接-以证明技术实力和项目经历。" aria-label="Permalink to &quot;如果有更多个人博客、GitHub项目或者曾经参与的开源项目，建议添加链接，以证明技术实力和项目经历。&quot;">​</a></h2><h2 id="怎么样理解前端开发-请结合您在华润网络有限公司作为前端开发工程师的经历来回答这个问题。" tabindex="-1">怎么样理解前端开发？请结合您在华润网络有限公司作为前端开发工程师的经历来回答这个问题。 <a class="header-anchor" href="#怎么样理解前端开发-请结合您在华润网络有限公司作为前端开发工程师的经历来回答这个问题。" aria-label="Permalink to &quot;怎么样理解前端开发？请结合您在华润网络有限公司作为前端开发工程师的经历来回答这个问题。&quot;">​</a></h2><h2 id="您提到熟悉使用vue全家桶开发项目-请描述您在华润通智能风控平台项目中是如何应用vue全家桶技术栈的" tabindex="-1">您提到熟悉使用Vue全家桶开发项目，请描述您在华润通智能风控平台项目中是如何应用Vue全家桶技术栈的？ <a class="header-anchor" href="#您提到熟悉使用vue全家桶开发项目-请描述您在华润通智能风控平台项目中是如何应用vue全家桶技术栈的" aria-label="Permalink to &quot;您提到熟悉使用Vue全家桶开发项目，请描述您在华润通智能风控平台项目中是如何应用Vue全家桶技术栈的？&quot;">​</a></h2><h2 id="请详细说明在使用vite进行项目配置时-遇到的一个技术挑战及您是如何解决的。" tabindex="-1">请详细说明在使用Vite进行项目配置时，遇到的一个技术挑战及您是如何解决的。 <a class="header-anchor" href="#请详细说明在使用vite进行项目配置时-遇到的一个技术挑战及您是如何解决的。" aria-label="Permalink to &quot;请详细说明在使用Vite进行项目配置时，遇到的一个技术挑战及您是如何解决的。&quot;">​</a></h2><h2 id="您提到实现了可视化大屏-能否举例说明在这方面的一个复杂问题及您如何解决它" tabindex="-1">您提到实现了可视化大屏，能否举例说明在这方面的一个复杂问题及您如何解决它？ <a class="header-anchor" href="#您提到实现了可视化大屏-能否举例说明在这方面的一个复杂问题及您如何解决它" aria-label="Permalink to &quot;您提到实现了可视化大屏，能否举例说明在这方面的一个复杂问题及您如何解决它？&quot;">​</a></h2><h2 id="在开发润酒店大屏-h5项目时-您如何协调处理web和h5两端的兼容性问题" tabindex="-1">在开发润酒店大屏/H5项目时，您如何协调处理Web和H5两端的兼容性问题？ <a class="header-anchor" href="#在开发润酒店大屏-h5项目时-您如何协调处理web和h5两端的兼容性问题" aria-label="Permalink to &quot;在开发润酒店大屏/H5项目时，您如何协调处理Web和H5两端的兼容性问题？&quot;">​</a></h2><h2 id="您在南康统计app项目中使用了uniapp-请问您认为使用跨平台框架开发与原生开发相比有哪些优劣势" tabindex="-1">您在南康统计APP项目中使用了Uniapp，请问您认为使用跨平台框架开发与原生开发相比有哪些优劣势？ <a class="header-anchor" href="#您在南康统计app项目中使用了uniapp-请问您认为使用跨平台框架开发与原生开发相比有哪些优劣势" aria-label="Permalink to &quot;您在南康统计APP项目中使用了Uniapp，请问您认为使用跨平台框架开发与原生开发相比有哪些优劣势？&quot;">​</a></h2><h2 id="能否提供一些性能优化的例子-您在哪些项目中做过哪些类型的优化" tabindex="-1">能否提供一些性能优化的例子？您在哪些项目中做过哪些类型的优化？ <a class="header-anchor" href="#能否提供一些性能优化的例子-您在哪些项目中做过哪些类型的优化" aria-label="Permalink to &quot;能否提供一些性能优化的例子？您在哪些项目中做过哪些类型的优化？&quot;">​</a></h2><h2 id="harmonyos应用开发有哪些独特之处-您是如何快速掌握并通过相关认证的" tabindex="-1">HarmonyOS应用开发有哪些独特之处，您是如何快速掌握并通过相关认证的？ <a class="header-anchor" href="#harmonyos应用开发有哪些独特之处-您是如何快速掌握并通过相关认证的" aria-label="Permalink to &quot;HarmonyOS应用开发有哪些独特之处，您是如何快速掌握并通过相关认证的？&quot;">​</a></h2><h2 id="对您来说-项目中最有挑战的部分是什么-请结合您的项目经历给出答案。" tabindex="-1">对您来说，项目中最有挑战的部分是什么？请结合您的项目经历给出答案。 <a class="header-anchor" href="#对您来说-项目中最有挑战的部分是什么-请结合您的项目经历给出答案。" aria-label="Permalink to &quot;对您来说，项目中最有挑战的部分是什么？请结合您的项目经历给出答案。&quot;">​</a></h2><h2 id="描述一下您解决复杂技术问题的一般流程以及如何在团队中交流这些问题。" tabindex="-1">描述一下您解决复杂技术问题的一般流程以及如何在团队中交流这些问题。 <a class="header-anchor" href="#描述一下您解决复杂技术问题的一般流程以及如何在团队中交流这些问题。" aria-label="Permalink to &quot;描述一下您解决复杂技术问题的一般流程以及如何在团队中交流这些问题。&quot;">​</a></h2><h2 id="vite-与-webpack-的区别" tabindex="-1">Vite 与 Webpack 的区别 <a class="header-anchor" href="#vite-与-webpack-的区别" aria-label="Permalink to &quot;Vite 与 Webpack 的区别&quot;">​</a></h2><p>模块与npm包的区别</p><pre><code>module / package
</code></pre><p>vite 构建优化方法</p><pre><code>构建体积优话
	terser / swc
 大文件切成小文件 chunk
	  http2
	  cache
</code></pre><p>强缓存 hash</p><p>http2 steram / frame</p><p>eslint extends flat config</p><h2 id="pnpm-yarn-npm-monorepo" tabindex="-1">pnpm / yarn / npm + monorepo <a class="header-anchor" href="#pnpm-yarn-npm-monorepo" aria-label="Permalink to &quot;pnpm / yarn / npm   +  monorepo&quot;">​</a></h2><h3 id="yarn-npm-的问题" tabindex="-1">yarn / npm 的问题 <a class="header-anchor" href="#yarn-npm-的问题" aria-label="Permalink to &quot;yarn / npm  的问题&quot;">​</a></h3><h4 id="性能较差" tabindex="-1">性能较差 <a class="header-anchor" href="#性能较差" aria-label="Permalink to &quot;性能较差&quot;">​</a></h4><p>npm必须首先遍历所有的项目依赖关系，然后再决定如何生成扁平的node_modules目录结构。</p><p>npm必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作，是npm安装速度慢的一个很重要的原因。</p><h4 id="本地缓存管理不足" tabindex="-1">本地缓存管理不足 <a class="header-anchor" href="#本地缓存管理不足" aria-label="Permalink to &quot;本地缓存管理不足&quot;">​</a></h4><p>npm 在管理本地缓存方面不如 Yarn 和 pnpm 高效，这可能导致重复下载同一依赖包，浪费时间和带宽</p><h4 id="嵌套依赖" tabindex="-1">嵌套依赖 <a class="header-anchor" href="#嵌套依赖" aria-label="Permalink to &quot;嵌套依赖&quot;">​</a></h4><p>因为这两者在2.x以下版本，npm安装包方式是以嵌套方式安装的包，而2.x版本以上则是平铺方式安装。</p><pre><code>npm 的 node_modules 是嵌套的。
这很正常呀？有什么不对么？
这样其实是有问题的，多个包之间难免会有公共的依赖，这样嵌套的话，同样的依赖会复制很多次，会占据比较大的磁盘空间。
这个还不是最大的问题，致命问题是 windows 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的。
</code></pre><p><strong>因为一个包是可能有多个版本的，提升只能提升一个，所以后面再遇到相同包的不同版本，依然还是用嵌套的方式。</strong></p><h4 id="幽灵依赖" tabindex="-1">幽灵依赖 <a class="header-anchor" href="#幽灵依赖" aria-label="Permalink to &quot;幽灵依赖&quot;">​</a></h4><p><strong><code>幽灵依赖就是你明明没有声明在 dependencies 里的依赖，但在代码里却可以 require 进来。</code></strong></p><p>幽灵依赖可能会导致以下问题：</p><ul><li>项目在不同的环境下表现不一致，因为安装的依赖项版本不同。</li><li>可能会安装未经测试的、低质量的或包含漏洞的软件包。</li><li>项目构建和部署过程可能会因为依赖项版本不兼容而失败。</li></ul><blockquote><p>yarn 和 npm 安装方法都是将项目依赖包原封不动的从服务器上下载到本地，写入到 node_modules 文件夹，而每个 package 又都有自己的 node_modules，所以当一个 package 在不同的依赖项中需要时，它会被多次复制粘贴并生成多份文件，形成一个很深的依赖树。</p></blockquote><h3 id="pnpm" tabindex="-1">pnpm <a class="header-anchor" href="#pnpm" aria-label="Permalink to &quot;pnpm&quot;">​</a></h3><p>pnpm 因为它采用了一种巧妙的方法，利用硬链接和<a href="https://www.zhihu.com/search?q=%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A542738352%7D" target="_blank" rel="noreferrer">符号链接(软链接)</a>来避免复制所有本地缓存<a href="https://www.zhihu.com/search?q=%E6%BA%90%E6%96%87%E4%BB%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A542738352%7D" target="_blank" rel="noreferrer">源文件</a>，这是yarn的最大的性能弱点之一。</p><p><strong>3.1硬链接和软连接</strong></p><p>硬连接就是同一个文件的不同引用，而软链接是新建一个文件，文件内容指向另一个路径。</p><blockquote><p>硬链接</p></blockquote><pre><code>在Linux的文件系统中，保存在[磁盘分区](https://www.zhihu.com/search?q=%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A542738352%7D)中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)，在 Linux 中，允许多个文件名指向同一索引节点，一般这种连接就是硬链接。  
硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到[重要文件](https://www.zhihu.com/search?q=%E9%87%8D%E8%A6%81%E6%96%87%E4%BB%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A542738352%7D)，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的链接。只删除一个链接并不影响索引节点本身和其它的链接，只有当最后一个链接被删除后，文件的数据块及目录的链接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬链接文件均被删除。
</code></pre><blockquote><p><strong>软连接</strong><br> 准确来说叫符号链接（symbolic link），一般又叫<a href="https://www.zhihu.com/search?q=%E8%BD%AF%E9%93%BE%E6%8E%A5&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A542738352%7D" target="_blank" rel="noreferrer">软链接</a>（soft link）。与硬链接共用一个inode不同，软链接会创建新的inode，并指向源文件。可以理解软链接就是windows系统中的桌面快捷方式。</p></blockquote><p><strong>3.2pnpm做了什么</strong></p><p>当使用 npm 或 Yarn 时，如果你有100个项目使用了某个依赖（dependency），就会有100份该依赖的副本保存在硬盘上。而在使用 pnpm 时，依赖会被存储在内容可寻址的存储中，所以： 如果你用到了某依赖项的不同版本，那么只会将有差异的文件添加到仓库。</p><blockquote><p>即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。举个例子，比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 hardlink，仅仅写入那一个新增的文件。</p></blockquote><p>所有文件都会存储在硬盘上的某一位置。 当<a href="https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E5%8C%85&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A542738352%7D" target="_blank" rel="noreferrer">软件包</a>被被安装时，包里的文件会 <strong>硬链接</strong> 到这一位置，而不会占用额外的磁盘空间。 这允许你跨项目地共享同一版本的依赖。因此，您在磁盘上节省了大量空间，这与项目和依赖项的数量成正比，并且安装速度要快得多！</p><p>pnpm 内部使用基于内容寻址的文件系统来存储磁盘上所有的文件，这个文件系统出色的地方在于: 同一个包 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使 hardlink。</p><p><strong>pnpm 为什么优秀呢？</strong></p><p>最大的优点是节省磁盘空间呀，一个包全局只保存一份，剩下的都是软硬连接，这得节省多少磁盘空间呀。</p><p>其次就是快，因为通过链接的方式而不是复制，自然会快。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>npm2 是通过嵌套的方式管理 node_modules 的，会有同样的依赖复制多次的问题。</p><p>npm3+ 和 yarn 是通过铺平的扁平化的方式来管理 node_modules，解决了嵌套方式的部分问题，但是引入了幽灵依赖的问题，并且同名的包只会提升一个版本的，其余的版本依然会复制多次。</p><p>pnpm 则是用了另一种方式，不再是复制了，而是都从全局 store 硬连接到 node_modules/.pnpm，然后之间通过软链接来组织依赖关系。</p><p>在比较 PNPM 和 Yarn 时，可以明显看出，无论缓存类型（冷或热）如何，PNPM 在速度方面都优于 Yarn。PNPM 速度快的关键在于其文件链接方法，它只需从全局存储中链接文件，而 Yarn 则采用从缓存中复制文件的方法。此外，PNPM 不会在磁盘上多次保存软件包版本，从而确保高效使用磁盘。</p><p>这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。</p><h2 id="为什么现在我更推荐-pnpm-而不是-npm-yarn" tabindex="-1">为什么现在我更推荐 pnpm 而不是 npm/yarn? <a class="header-anchor" href="#为什么现在我更推荐-pnpm-而不是-npm-yarn" aria-label="Permalink to &quot;为什么现在我更推荐 pnpm 而不是 npm/yarn?&quot;">​</a></h2><h3 id="一、什么是-pnpm" tabindex="-1">一、什么是 pnpm ? <a class="header-anchor" href="#一、什么是-pnpm" aria-label="Permalink to &quot;一、什么是 pnpm ?&quot;">​</a></h3><p>pnpm 的<a href="https://link.juejin.cn?target=https%3A%2F%2Fpnpm.js.org%2Fen%2F" title="https://pnpm.js.org/en/" target="_blank" rel="noreferrer">官方文档</a>是这样说的:</p><blockquote><p>Fast, disk space efficient package manager</p></blockquote><p>因此，pnpm 本质上就是一个包管理器，这一点跟 npm/yarn 没有区别，但它作为杀手锏的两个优势在于:</p><ul><li>包安装速度极快；</li><li>磁盘空间利用非常高效。</li></ul><p>它的安装也非常简单。可以有多简单</p><h3 id="二、特性概览" tabindex="-1">二、特性概览 <a class="header-anchor" href="#二、特性概览" aria-label="Permalink to &quot;二、特性概览&quot;">​</a></h3><h4 id="_1-速度快" tabindex="-1">1. 速度快 <a class="header-anchor" href="#_1-速度快" aria-label="Permalink to &quot;1. 速度快&quot;">​</a></h4><h4 id="_2-高效利用磁盘空间" tabindex="-1">2. 高效利用磁盘空间 <a class="header-anchor" href="#_2-高效利用磁盘空间" aria-label="Permalink to &quot;2. 高效利用磁盘空间&quot;">​</a></h4><p>pnpm 内部使用<code>基于内容寻址</code>的文件系统来存储磁盘上所有的文件，这个文件系统出色的地方在于:</p><ul><li><p>不会重复安装同一个包。用 npm/yarn 的时候，如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。但在使用 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用 <code>hardlink</code>(硬链接，不清楚的同学详见<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fitech%2Farchive%2F2009%2F04%2F10%2F1433052.html" title="https://www.cnblogs.com/itech/archive/2009/04/10/1433052.html" target="_blank" rel="noreferrer">这篇文章</a>)。</p></li><li><p>即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。举个例子，比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 <code>hardlink</code>，仅仅写入那<code>一个新增的文件</code>。</p></li></ul><h4 id="_3-支持-monorepo" tabindex="-1">3. 支持 monorepo <a class="header-anchor" href="#_3-支持-monorepo" aria-label="Permalink to &quot;3. 支持 monorepo&quot;">​</a></h4><p>随着前端工程的日益复杂，越来越多的项目开始使用 monorepo。之前对于多个项目的管理，我们一般都是使用多个 git 仓库，但 monorepo 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的<code>packages</code>目录下，那么一个子项目就代表一个<code>package</code>。如果你之前没接触过 monorepo 的概念，建议仔细看看<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.perforce.com%2Fblog%2Fvcs%2Fwhat-monorepo" title="https://www.perforce.com/blog/vcs/what-monorepo" target="_blank" rel="noreferrer">这篇文章</a>以及开源的 monorepo 管理工具<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flerna%2Flerna%23readme" title="https://github.com/lerna/lerna#readme" target="_blank" rel="noreferrer">lerna</a>，项目目录结构可以参考一下 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel" title="https://github.com/babel/babel" target="_blank" rel="noreferrer">babel 仓库</a>。</p><p>pnpm 与 npm/yarn 另外一个很大的不同就是支持了 monorepo，体现在各个子命令的功能上，比如在根目录下 <code>pnpm add A -r</code>, 那么所有的 package 中都会被添加 A 这个依赖，当然也支持 <code>--filter</code>字段来对 package 进行过滤。</p><h4 id="_4-安全性高" tabindex="-1">4. 安全性高 <a class="header-anchor" href="#_4-安全性高" aria-label="Permalink to &quot;4. 安全性高&quot;">​</a></h4><p>之前在使用 npm/yarn 的时候，由于 node_module 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖。因此会出现这种非法访问的情况。但 pnpm 脑洞特别大，自创了一套依赖管理方式，很好地解决了这个问题，保证了安全性，具体怎么体现<code>安全</code>、规避非法访问依赖的<code>风险</code>的，后面再来详细说说。</p><h3 id="三、依赖管理" tabindex="-1">三、依赖管理 <a class="header-anchor" href="#三、依赖管理" aria-label="Permalink to &quot;三、依赖管理&quot;">​</a></h3><h4 id="npm-yarn-install-原理" tabindex="-1">npm/yarn install 原理 <a class="header-anchor" href="#npm-yarn-install-原理" aria-label="Permalink to &quot;npm/yarn install 原理&quot;">​</a></h4><p>主要分为两个部分, 首先，执行 npm/yarn install之后，<code>包如何到达项目 node_modules 当中</code>。其次，node_modules <code>内部如何管理依赖</code>。</p><p>执行命令后，首先会构建依赖树，然后针对每个节点下的包，会经历下面四个步骤:</p><ul><li><ol><li>将依赖包的版本区间解析为某个具体的版本号</li></ol></li><li><ol start="2"><li>下载对应版本依赖的 tar 包到本地离线镜像</li></ol></li><li><ol start="3"><li>将依赖从离线镜像解压到本地缓存</li></ol></li><li><ol start="4"><li>将依赖从缓存拷贝到当前目录的 node_modules 目录</li></ol></li></ul><p>然后，对应的包就会到达项目的<code>node_modules</code>当中。</p><p>那么，这些依赖在<code>node_modules</code>内部是什么样的目录结构呢，换句话说，项目的依赖树是什么样的呢？</p><p>在 <code>npm1</code>、<code>npm2</code> 中呈现出的是嵌套结构，比如下面这样:</p>`,84)])])}const u=a(t,[["render",p]]);export{m as __pageData,u as default};
