import{_ as s,c as i,o as a,a5 as n}from"./chunks/framework.C9ySr1fn.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"front/harmony/code_performance.md","filePath":"front/harmony/code_performance.md","lastUpdated":1723738320000}'),t={name:"front/harmony/code_performance.md"},l=n(`<h3 id="_1-布局性能优化" tabindex="-1">1. 布局性能优化 <a class="header-anchor" href="#_1-布局性能优化" aria-label="Permalink to &quot;1. 布局性能优化&quot;">​</a></h3><p>布局使用不当，如嵌套层级过深会导致页面卡顿、掉帧、响应慢等问题。</p><p>测算(Measure)：负责确定组件对象的测量宽/高 布局(Layout)：确定组件的最终宽/高和四个顶点的位置</p><ul><li><p><strong>精简节点数</strong>：移除冗余节点、扁平化布局（使用更高级的布局使页面扁平化，如RelativeContainer、Grid布局等）</p></li><li><p><strong>合理控制元素显示与隐藏</strong>（if条件渲染、visibility属性）</p><ul><li>在对性能要求较高，并且会频繁切换元素的显示与隐藏的情况下，应该避免使用if条件判断而改为通过visibility的属性控制。</li><li>如果组件的创建非常消耗资源，且不会立即使用，也并非频繁切换交互的情况下，只在特定条件下才会出现时，可以通过if条件渲染来进行内容的显示与隐藏控制，达到懒加载的效果。</li></ul></li><li><p><strong>给定组件的宽高</strong>：重新绘制时，限定容器宽高为固定值的情况下，性能提升明显。 对于组件的宽高不需要自适应的情况下，当其组件外部的容器尺寸发生变化时，建议给定组件的宽高数值。</p></li><li><p><strong>使用推荐的布局组件</strong></p><ul><li>在相同嵌套层级的情况下，如果多种布局方式可以实现相同布局效果，优选低耗时的布局，如使用Column、Row替代Flex实现相同的单行布局</li><li>在能够通过其他布局大幅优化节点数的情况下，可以使用高级组件替代，例如使用RelativeContainer替代Row、Column实现扁平化布局，此时其收益大于布局组件本身的性能差距</li><li>仅在必要的场景下使用高耗时的布局组件，如使用Flex实现折行布局、使用Grid实现二维网格布局等</li></ul></li></ul><h3 id="_2-长列表加载性能优化" tabindex="-1">2. 长列表加载性能优化 <a class="header-anchor" href="#_2-长列表加载性能优化" aria-label="Permalink to &quot;2. 长列表加载性能优化&quot;">​</a></h3><p>针对长列表加载这一场景，对列表渲染时间、页面滑动帧率、应用内存占用等方面带来优化，提升性能和用户体验的手段有如下4种:</p><p><strong>懒加载</strong>：提供列表数据按需加载能力，解决一次性加载长列表数据耗时长、占用过多资源的问题。 <strong>缓存列表项</strong>：通过预加载数据提升列表滑动体验。 <strong>组件复用</strong>：提供可复用组件对象的缓存资源池，降低相同组件短时间内频繁创建和销毁的开销。 <strong>布局优化</strong>：使用扁平化布局方案，减少视图嵌套层级和组件数，避免过度绘制，提升页面渲染效率。</p><h4 id="三个性能衡量关键指标" tabindex="-1">三个性能衡量关键指标 <a class="header-anchor" href="#三个性能衡量关键指标" aria-label="Permalink to &quot;三个性能衡量关键指标&quot;">​</a></h4><ul><li><strong>完全显示所用时间(Time To Ful Display， TTFD)</strong>：表示应用生成具有完整内容的第一帧所用的时间，包括在第一帧之后异步加载的内容。</li><li><strong>丢帧率(Janky Frames)</strong>：表示一个时间周期内的丢帧比率，是指一个时间周期内有问题的帧比例。HarmonyOS系统要求每一帧都要在<code>11.1ms(90Hz刷新率)</code>内绘制完成，如果页面没有在11.1ms内完成这一帧的绘制，就会出现丢帧。部分丢帧一般用户肉眼是感知不到的，只有出现连续丢帧用户才有明显感知。</li><li><strong>独占内存(Unique Set Size，UsS)</strong>：一个进程所占用的私有内存，即该进程独占的内存。它反映了运行一个特定进程真实的边际成本(增量成本)</li></ul><h4 id="优化1-懒加载" tabindex="-1">优化1：懒加载 <a class="header-anchor" href="#优化1-懒加载" aria-label="Permalink to &quot;优化1：懒加载&quot;">​</a></h4><p><strong>ForEach</strong>会从列表数据源一次性加载全量数据。如果列表数据较少，数据一次性全量加载不是性能瓶颈时，可以直接使用ForEach。</p><p><strong>LazyForEach</strong>实现了按需加载，针对列表数据量大、列表组件复杂的场景，减少了页面首次启动时一次性加载数据的时间消耗，减少了内存峰值。</p><blockquote><p>遗留问题：<strong>滑动白块现象</strong> 如果LazyForEach页面一次可以显示3条数据，如果不提前缓存部分数据，当下滑到列表最底端时，再快速下滑，可能会引起“滑动白块”的现象。这是因为上一次只请求了屏幕上的3条数据，如果滑动速度过快，则会导致数据来不及加载而出现白块。在追求极致性能的同时，应该避免这样糟糕的用户体验。</p></blockquote><h4 id="优化2-缓存列表项" tabindex="-1">优化2：缓存列表项 <a class="header-anchor" href="#优化2-缓存列表项" aria-label="Permalink to &quot;优化2：缓存列表项&quot;">​</a></h4><p>LazyForEach懒加载可以通过设置cachedCount来指定缓存数量，在设置cachedCount后，除屏幕内显示的Listltem组件外，还会预先将屏幕可视区外指定数量的列表项数据缓存。这样当一个屏幕数据加载完成后，再次向下滑动时，会先加载上一次请求的数据，加载完成后，再加载本次请求的数据。</p><p><strong>LazyForEach</strong>懒加载可以通过设置<code>cachedCount</code>属性来指定缓存数量</p><blockquote><p>不同cachedCount对列表滑动帧率的影响 一般而言，<strong>缓存的cachedCount=n/2(n为一屏显示的列表数)</strong> 的时候，效果较好。在实际开发中也要根据实际场景合理去设置缓存数量:</p><ul><li>例如列表项中需要显示网络加载较慢的数据，为了提升列表信息的浏览效率和浏览体验，我们可以适当的<strong>多设置一些缓存数量(cachedCount大于n/2)</strong>;</li><li>如果列表中需要加载一些大图或者视频等占用的内存较大的数据，为了减少内存占用，我们需要适当<strong>减少缓存数量的设置(cachedCount小于n/2)</strong> 因此，在实际场景中，需要不断尝试验证，设置适当的缓存数量，来达到体验和内存的平衡。</li></ul></blockquote><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@Component </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Struct MyComponent{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		list</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			// ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">			LazyForEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cachedCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="优化3-组件复用" tabindex="-1">优化3：组件复用 <a class="header-anchor" href="#优化3-组件复用" aria-label="Permalink to &quot;优化3：组件复用&quot;">​</a></h4><p>HarmonyOS应用框架提供了组件复用能力，可复用组件从组件树上移除时，会进入到一个回收缓存区。后续创建新组件节点时，会复用缓存区中的节点，节约组件重新创建的时间。尤其在列表等场景下，其自定义子组件具有相同的组件布局结构，列表更新时仅有状态变量等数据差异。通过组件复用可以提高列表页面的加载速度和响应速度。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@Component</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@Reusable     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1.使用@Reusable标识表示其具备组件复用能力</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> struct ArticleCardView{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	@Prop isCollected:boolean = false;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	@Prop isLiked:boolean = false;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	@Prop articleItem:LearningResource = new LearningResource();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	onCollected?:()=&gt; void;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	onLiked?:()=&gt; void;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 2.实现自定义组件的生命周期回调函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	aboutToReuse(params: Record&lt;string,Object&gt;):void{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		this.onCollected = params.onCollected as ()=&gt; void;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		this.onLiked = params.onLiked as ()=&gt; void;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@Component</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> struct DiscoverView{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	private data:ArticleListData = new ArticleListData();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	build(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		List(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			Column(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">				LazyForEach(this.data,(item:LearningResource)=&gt;{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">					ListItem(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">						Column(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">							ArticlecardView({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">								articleItem:item</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">								...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">							})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">						}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 3、设置可复用组件的reuseld如果有多个可复用的组件，要设置多个reuseld</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">					}.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reuseId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ArticleCardView&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">				},，(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">LearningResource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">item.id))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cachedcount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="优化4-布局优化" tabindex="-1">优化4：布局优化 <a class="header-anchor" href="#优化4-布局优化" aria-label="Permalink to &quot;优化4：布局优化&quot;">​</a></h4><p>列表不同于其他布局，包含了大量重复循环的Listltem，所以对每一个Listltem的布局优化格外重要。错误的布局方式可能会导致组件树和嵌套层数过多，在创建和布局绘制阶段产生较大的性能开销，导致界面卡顿。合理使用布局，减少嵌套层数，能提高布局效率。</p><p>布局过度嵌套会导致应用内存增加，且会影响应用的帧率导致丢帧增加，所以开发者在写列表这类循环组件的代码时需要特别考虑对其布局进行优化。一般而言<strong>布局的最大嵌套层级控制在5-8层左右即可</strong>，过度的去优化布局会导致代码开发难度加大，代码不易于阅读理解，增加后续的维护成本，不利于多设备的适配，且也不会带来特别显著的性能提升。</p>`,24),e=[l];function p(h,k,r,E,o,d){return a(),i("div",null,e)}const y=s(t,[["render",p]]);export{g as __pageData,y as default};
