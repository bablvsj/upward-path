import{_ as a,c as e,o as s,a5 as n}from"./chunks/framework.CLn23qdP.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue2.md","filePath":"interview/vue2.md","lastUpdated":1720777974000}'),p={name:"interview/vue2.md"},t=n(`<h3 id="_147-vue-的各个生命阶段是什么" tabindex="-1">147. Vue 的各个生命阶段是什么？ <a class="header-anchor" href="#_147-vue-的各个生命阶段是什么" aria-label="Permalink to &quot;147. Vue 的各个生命阶段是什么？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（1）beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（2）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（3）beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（4）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（5）beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（6）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（7）beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（8）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</span></span></code></pre></div><p>详细资料可以参考： <a href="https://juejin.im/entry/5aee8fbb518825671952308c" target="_blank" rel="noreferrer">《vue 生命周期深入》</a><a href="https://cn.vuejs.org/v2/guide/instance.html" target="_blank" rel="noreferrer">《Vue 实例》</a></p><h3 id="_151-route-和-router-的区别" tabindex="-1">151. $route 和 $router 的区别？ <a class="header-anchor" href="#_151-route-和-router-的区别" aria-label="Permalink to &quot;151. $route 和 $router 的区别？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</span></span></code></pre></div><h3 id="_152-vue-常用的修饰符" tabindex="-1">152. vue 常用的修饰符？ <a class="header-anchor" href="#_152-vue-常用的修饰符" aria-label="Permalink to &quot;152. vue 常用的修饰符？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；</span></span></code></pre></div><h3 id="_153-vue-中-key-值的作用" tabindex="-1">153. vue 中 key 值的作用？ <a class="header-anchor" href="#_153-vue-中-key-值的作用" aria-label="Permalink to &quot;153. vue 中 key 值的作用？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>vue 中 key 值的作用可以分为两种情况来考虑。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</span></span></code></pre></div><p>详细资料可以参考： <a href="https://segmentfault.com/a/1190000016344599" target="_blank" rel="noreferrer">《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》</a><a href="https://www.zhihu.com/question/61064119" target="_blank" rel="noreferrer">《Vue2.0 v-for 中 :key 到底有什么用？》</a><a href="https://www.cnblogs.com/RainyBear/p/8563101.html" target="_blank" rel="noreferrer">《vue 中 key 的作用》</a></p><h3 id="_155-keep-alive-组件有什么作用" tabindex="-1">155. keep-alive 组件有什么作用？ <a class="header-anchor" href="#_155-keep-alive-组件有什么作用" aria-label="Permalink to &quot;155. keep-alive 组件有什么作用？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</span></span></code></pre></div>`,12),l=[t];function i(r,o,c,d,u,h){return s(),e("div",null,l)}const k=a(p,[["render",i]]);export{b as __pageData,k as default};
