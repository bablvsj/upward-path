import{_ as a,c as e,o as s,a5 as n}from"./chunks/framework.CLn23qdP.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue2.md","filePath":"interview/vue2.md","lastUpdated":1721144552000}'),p={name:"interview/vue2.md"},t=n(`<h3 id="_147-vue-的各个生命阶段是什么" tabindex="-1">147. Vue 的各个生命阶段是什么？ <a class="header-anchor" href="#_147-vue-的各个生命阶段是什么" aria-label="Permalink to &quot;147. Vue 的各个生命阶段是什么？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（1）beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（2）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（3）beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（4）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（5）beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（6）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（7）beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>（8）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</span></span></code></pre></div><p>详细资料可以参考： <a href="https://juejin.im/entry/5aee8fbb518825671952308c" target="_blank" rel="noreferrer">《vue 生命周期深入》</a><a href="https://cn.vuejs.org/v2/guide/instance.html" target="_blank" rel="noreferrer">《Vue 实例》</a></p><h3 id="_151-route-和-router-的区别" tabindex="-1">151. $route 和 $router 的区别？ <a class="header-anchor" href="#_151-route-和-router-的区别" aria-label="Permalink to &quot;151. $route 和 $router 的区别？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</span></span></code></pre></div><h3 id="_152-vue-常用的修饰符" tabindex="-1">152. vue 常用的修饰符？ <a class="header-anchor" href="#_152-vue-常用的修饰符" aria-label="Permalink to &quot;152. vue 常用的修饰符？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；</span></span></code></pre></div><h3 id="_153-vue-中-key-值的作用" tabindex="-1">153. vue 中 key 值的作用？ <a class="header-anchor" href="#_153-vue-中-key-值的作用" aria-label="Permalink to &quot;153. vue 中 key 值的作用？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>vue 中 key 值的作用可以分为两种情况来考虑。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</span></span></code></pre></div><p>详细资料可以参考： <a href="https://segmentfault.com/a/1190000016344599" target="_blank" rel="noreferrer">《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》</a><a href="https://www.zhihu.com/question/61064119" target="_blank" rel="noreferrer">《Vue2.0 v-for 中 :key 到底有什么用？》</a><a href="https://www.cnblogs.com/RainyBear/p/8563101.html" target="_blank" rel="noreferrer">《vue 中 key 的作用》</a></p><h3 id="_155-keep-alive-组件有什么作用" tabindex="-1">155. keep-alive 组件有什么作用？ <a class="header-anchor" href="#_155-keep-alive-组件有什么作用" aria-label="Permalink to &quot;155. keep-alive 组件有什么作用？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</span></span></code></pre></div><h3 id="_109-vue-双向数据绑定原理" tabindex="-1">109. vue 双向数据绑定原理？ <a class="header-anchor" href="#_109-vue-双向数据绑定原理" aria-label="Permalink to &quot;109. vue 双向数据绑定原理？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>首先我们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数</span></span>
<span class="line"><span>据。</span></span></code></pre></div><p>详细资料可以参考： <a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension" target="_blank" rel="noreferrer">《Vue.js 双向绑定的实现原理》</a></p><h3 id="_110-object-defineproperty-介绍" tabindex="-1">110. Object.defineProperty 介绍？ <a class="header-anchor" href="#_110-object-defineproperty-介绍" aria-label="Permalink to &quot;110. Object.defineProperty 介绍？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Object.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。</span></span></code></pre></div><p>详细资料可以参考： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noreferrer">《Object.defineProperty()》</a></p><h3 id="_111-使用-object-defineproperty-来进行数据劫持有什么缺点" tabindex="-1">111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？ <a class="header-anchor" href="#_111-使用-object-defineproperty-来进行数据劫持有什么缺点" aria-label="Permalink to &quot;111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。</span></span></code></pre></div><h3 id="_112-什么是-virtual-dom-为什么-virtual-dom-比原生-dom-快" tabindex="-1">112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？ <a class="header-anchor" href="#_112-什么是-virtual-dom-为什么-virtual-dom-比原生-dom-快" aria-label="Permalink to &quot;112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>我对 Virtual DOM 的理解是，</span></span>
<span class="line"><span></span></span>
<span class="line"><span>首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</span></span></code></pre></div><p>详细资料可以参考： <a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf" target="_blank" rel="noreferrer">《Virtual DOM》</a><a href="https://github.com/y8n/blog/issues/5" target="_blank" rel="noreferrer">《理解 Virtual DOM》</a><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noreferrer">《深度剖析：如何实现一个 Virtual DOM 算法》</a><a href="https://www.zhihu.com/question/31809713/answer/53544875" target="_blank" rel="noreferrer">《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》</a></p>`,23),l=[t];function i(r,o,c,d,u,h){return s(),e("div",null,l)}const g=a(p,[["render",i]]);export{v as __pageData,g as default};
